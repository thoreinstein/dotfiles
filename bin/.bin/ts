#!/usr/bin/env bash
#
# ts - Tmux Session Switcher
#
# A fast project switcher for tmux that finds Git repositories and worktrees
# under BASE_DIR and presents them via fzf for quick session switching.
#
# Usage: ts [OPTIONS]
#   -u, --update    Force update the repository cache
#   -h, --help      Show help message
#
# Environment:
#   TS_BASE_DIR     Override default base directory (default: ~/src)
#   TS_CACHE_FILE   Override cache file location
#   TS_CACHE_AGE    Override cache max age in seconds (default: 3600)

set -euo pipefail

# Save original directory to restore later
ORIGINAL_DIR="$PWD"
trap 'cd "$ORIGINAL_DIR" 2>/dev/null || true' EXIT

BASE_DIR="${TS_BASE_DIR:-${HOME}/src}"
CACHE_FILE="${TS_CACHE_FILE:-${HOME}/.cache/ts_repos.cache}"
CACHE_MAX_AGE="${TS_CACHE_AGE:-3600}"  # 1 hour in seconds

# Parse command line arguments
UPDATE_CACHE=false
if [[ "${1:-}" == "--update" ]] || [[ "${1:-}" == "-u" ]]; then
  UPDATE_CACHE=true
elif [[ "${1:-}" == "--help" ]] || [[ "${1:-}" == "-h" ]]; then
  echo "Usage: ts [OPTIONS]"
  echo ""
  echo "Tmux session switcher for Git repositories"
  echo ""
  echo "Options:"
  echo "  -u, --update    Force update the repository cache"
  echo "  -h, --help      Show this help message"
  echo ""
  echo "The script caches repository information for 1 hour to improve performance."
  echo "Use --update to force a refresh of the cache."
  exit 0
fi

# Check for required dependencies
for cmd in tmux git fzf; do
  if ! command -v "$cmd" &> /dev/null; then
    echo "Error: Required command '$cmd' not found" >&2
    exit 1
  fi
done

# Check if BASE_DIR exists
if [[ ! -d "$BASE_DIR" ]]; then
  echo "Error: Base directory '$BASE_DIR' does not exist" >&2
  exit 1
fi

# Ensure cache directory exists
mkdir -p "$(dirname "$CACHE_FILE")"

declare -a options

# Function to check if cache is valid
is_cache_valid() {
  if [[ ! -f "$CACHE_FILE" ]]; then
    return 1
  fi

  local cache_time
  # GNU coreutils stat (requires: brew install coreutils)
  cache_time=$(stat -c "%Y" -- "$CACHE_FILE" 2>/dev/null || echo 0)
  local current_time
  current_time=$(date +%s)
  local age=$((current_time - cache_time))

  [[ $age -lt $CACHE_MAX_AGE ]]
}

# Function to build repository list
build_repo_list() {
  local -a temp_options=()

  echo "Scanning repositories in $BASE_DIR..." >&2

  # Find all Git repositories
  # We look for:
  #   1. Regular repos: directories containing .git subdirectory
  #   2. Bare repos: directories containing both objects/ and refs/ subdirectories
  while IFS= read -r repo_path; do
    [[ -z "$repo_path" ]] && continue

    if [[ -d "$repo_path/.git" ]]; then
      # Regular Git repository
      repo_name=$(basename "$repo_path")

      # Get current branch (run in subshell to avoid cd side effects)
      branch_name=$(cd "$repo_path" 2>/dev/null && git branch --show-current 2>/dev/null) || branch_name=""
      [[ -z "$branch_name" ]] && branch_name="detached"

      # Get git status
      status=$(get_regular_git_status "$repo_path")

      # Get remote info
      remote_info=$(get_regular_remote_info "$repo_path")

      # Truncate long values for better table formatting
      truncated_remote=$(truncate_string "$remote_info" 25)
      truncated_repo=$(truncate_string "$repo_name" 18)
      truncated_branch=$(truncate_string "$branch_name" 20)
      truncated_worktree=$(truncate_string "$repo_name" 15)

      # Format the display line
      option_line=$(printf "%-25s | %-18s | %-15s | %-20s | %-8s\t%s\t%s\t%s" \
        "$truncated_remote" \
        "$truncated_repo" \
        "$truncated_worktree" \
        "$truncated_branch" \
        "$status" \
        "$repo_name" \
        "$repo_name" \
        "$repo_path")

      temp_options+=("$option_line")

    elif [[ -d "$repo_path/objects" ]] && [[ -d "$repo_path/refs" ]] && [[ -f "$repo_path/HEAD" ]]; then
      # Bare repository with worktrees (also check for HEAD file to confirm it's a git dir)
      repo_name=$(basename "$repo_path")

      # Safely get worktree list
      if worktrees=$(git --git-dir="$repo_path" worktree list 2>/dev/null); then
        while IFS= read -r line; do
          [[ -z "$line" ]] && continue
          # Parse worktree list output: /path/to/worktree  abc1234 [branch]
          # The format uses spaces, not tabs
          if [[ "$line" =~ ^([^[:space:]]+)[[:space:]]+([0-9a-f]{7,})[[:space:]]*(\[.+\])?$ ]]; then
            worktree_path="${BASH_REMATCH[1]}"
            branch_info="${BASH_REMATCH[3]:-}"

            worktree_name=$(basename "$worktree_path")

            # Extract branch name from bracket info or get current branch
            if [[ -n "$branch_info" ]]; then
              branch_name="${branch_info//[\[\]]/}"
            else
              # Get current branch for detached HEAD or bare repo main worktree
              branch_name=$(cd "$worktree_path" 2>/dev/null && \
                git --git-dir="$repo_path" --work-tree="$worktree_path" branch --show-current 2>/dev/null) || branch_name=""
              [[ -z "$branch_name" ]] && branch_name="detached"
            fi

            # Get git status
            status=$(get_git_status "$worktree_path" "$repo_path")

            # Get remote info (GitHub org/repo)
            remote_info=$(get_remote_info "$repo_path" "$worktree_path")

            # Truncate long values for better table formatting
            truncated_remote=$(truncate_string "$remote_info" 25)
            truncated_repo=$(truncate_string "$repo_name" 18)
            truncated_branch=$(truncate_string "$branch_name" 20)
            truncated_worktree=$(truncate_string "$worktree_name" 15)

            # Format the display line with consistent spacing
            option_line=$(printf "%-25s | %-18s | %-15s | %-20s | %-8s\t%s\t%s\t%s" \
              "$truncated_remote" \
              "$truncated_repo" \
              "$truncated_worktree" \
              "$truncated_branch" \
              "$status" \
              "$worktree_name" \
              "$repo_name" \
              "$worktree_path")

            temp_options+=("$option_line")
          fi
        done <<< "$worktrees"
      fi
    fi
  done < <(find "$BASE_DIR" -maxdepth 4 -type d -name ".git" -exec dirname {} \; 2>/dev/null; \
           find "$BASE_DIR" -maxdepth 4 -type d -name "objects" -exec dirname {} \; 2>/dev/null | sort -u)

  # Save to cache (handle empty array case)
  if [[ ${#temp_options[@]} -gt 0 ]]; then
    printf '%s\n' "${temp_options[@]}" > "$CACHE_FILE"
  else
    : > "$CACHE_FILE"  # Create empty cache file
  fi
  echo "Repository cache updated (${#temp_options[@]} repositories found)" >&2

  # Return the options
  options=("${temp_options[@]+"${temp_options[@]}"}")
}

# Helper function to truncate strings with ellipsis
truncate_string() {
  local str="$1"
  local max_len="$2"

  if [[ ${#str} -le $max_len ]]; then
    echo "$str"
  else
    echo "${str:0:$((max_len - 3))}..."
  fi
}

switch_to() {
  local session_name="$1"
  if [[ -z "${TMUX:-}" ]]; then
    tmux attach-session -t "=$session_name"
  else
    tmux switch-client -t "=$session_name"
  fi
}

has_session() {
  local session_name="$1"
  # Use exact match with = prefix to avoid regex issues with special chars like [ ]
  tmux has-session -t "=$session_name" 2>/dev/null
}

get_git_status() {
  local worktree_path="$1"
  local git_dir="$2"

  if [[ ! -d "$worktree_path" ]]; then
    echo "Missing"
    return
  fi

  # Run git commands with explicit paths (no cd needed)
  local porcelain_output
  porcelain_output=$(git --git-dir="$git_dir" --work-tree="$worktree_path" status --porcelain 2>/dev/null) || {
    echo "Error"
    return
  }

  if [[ -z "$porcelain_output" ]]; then
    echo "Clean"
  elif echo "$porcelain_output" | grep -q '^[MADRC]'; then
    # Staged changes (first column has status letter)
    echo "Staged"
  else
    # Unstaged changes or untracked files
    echo "Dirty"
  fi
}

get_remote_info() {
  local git_dir="$1"
  local worktree_path="$2"

  # Get the remote URL (no cd needed with explicit git-dir)
  local remote_url
  remote_url=$(git --git-dir="$git_dir" remote get-url origin 2>/dev/null) || remote_url=""

  if [[ -z "$remote_url" ]]; then
    echo "local/local"
    return
  fi

  # Parse GitHub/GitLab/etc URL (supports both SSH and HTTPS)
  # SSH: git@github.com:org/repo.git
  # HTTPS: https://github.com/org/repo.git
  if [[ "$remote_url" =~ (github|gitlab|bitbucket)\.com[:/]([^/]+)/([^/.]+) ]]; then
    local org="${BASH_REMATCH[2]}"
    local repo="${BASH_REMATCH[3]}"
    echo "$org/$repo"
  else
    # For non-GitHub or unrecognized URLs
    local basename_repo
    basename_repo=$(basename "$remote_url" .git)
    echo "other/$basename_repo"
  fi
}

# Function to get git status for regular repos
get_regular_git_status() {
  local repo_path="$1"

  # Run git commands with explicit work-tree (no cd needed)
  local porcelain_output
  porcelain_output=$(git -C "$repo_path" status --porcelain 2>/dev/null) || {
    echo "Error"
    return
  }

  if [[ -z "$porcelain_output" ]]; then
    echo "Clean"
  elif echo "$porcelain_output" | grep -q '^[MADRC]'; then
    # Staged changes (first column has status letter)
    echo "Staged"
  else
    # Unstaged changes or untracked files
    echo "Dirty"
  fi
}

# Function to get remote info for regular repos
get_regular_remote_info() {
  local repo_path="$1"

  # Get the remote URL (no cd needed with -C)
  local remote_url
  remote_url=$(git -C "$repo_path" remote get-url origin 2>/dev/null) || remote_url=""

  if [[ -z "$remote_url" ]]; then
    echo "local/local"
    return
  fi

  # Parse GitHub/GitLab/etc URL (supports both SSH and HTTPS)
  if [[ "$remote_url" =~ (github|gitlab|bitbucket)\.com[:/]([^/]+)/([^/.]+) ]]; then
    local org="${BASH_REMATCH[2]}"
    local repo="${BASH_REMATCH[3]}"
    echo "$org/$repo"
  else
    # For non-GitHub or unrecognized URLs
    local basename_repo
    basename_repo=$(basename "$remote_url" .git)
    echo "other/$basename_repo"
  fi
}

# Load repository list (from cache or build fresh)
if [[ "$UPDATE_CACHE" == "true" ]] || ! is_cache_valid; then
  build_repo_list
else
  # Load from cache
  while IFS= read -r line; do
    options+=("$line")
  done < "$CACHE_FILE"
fi

# Check if we have any options
if [[ ${#options[@]} -eq 0 ]]; then
  echo "No git repositories found in $BASE_DIR" >&2
  exit 1
fi

# Present options via fzf with better formatting
selected=$(printf '%s\n' "${options[@]}" | fzf \
  --tmux 100%,90% \
  --with-nth=1 \
  --delimiter=$'\t' \
  --preview='echo "Path: {4}"; echo ""; ls -la {4}' \
  --layout=reverse \
  --prompt='Select Repository > ' \
  --header="$(printf "%-25s | %-18s | %-15s | %-20s | %-8s" "GitHub Org/Repo" "Repository" "Worktree" "Branch" "Status")" \
  --bind='?:toggle-preview' 2>/dev/null) || exit 0

# Check if selection is empty (shouldn't happen with new exit handling, but just in case)
if [[ -z "$selected" ]]; then
  exit 0
fi

# Extract fields from the selected line
IFS=$'\t' read -r _ worktree_name repo_name selected_path <<< "$selected"

# Validate extracted fields
if [[ -z "$worktree_name" ]] || [[ -z "$repo_name" ]] || [[ -z "$selected_path" ]]; then
  echo "Error: Failed to parse selection" >&2
  exit 1
fi

# Verify the selected path exists
if [[ ! -d "$selected_path" ]]; then
  echo "Error: Selected path '$selected_path' does not exist" >&2
  exit 1
fi

worktree=$(echo "$worktree_name" | xargs)
# Construct the session name as 'repo_name [worktree_name]'
selected_name="${repo_name} [${worktree}]"

# Check if tmux server is running
tmux_running=false
if tmux list-sessions &>/dev/null; then
  tmux_running=true
fi

if [[ -z "${TMUX:-}" ]] && [[ "$tmux_running" == "false" ]]; then
  # No tmux session exists and we're not inside tmux - create and attach
  if ! tmux new-session -s "$selected_name" -c "$selected_path"; then
    echo "Error: Failed to create new tmux session" >&2
    exit 1
  fi
  exit 0
fi

# Create session if it doesn't exist
if ! has_session "$selected_name"; then
  if ! tmux new-session -ds "$selected_name" -c "$selected_path"; then
    echo "Error: Failed to create detached tmux session" >&2
    exit 1
  fi
fi

# Switch to the session
if ! switch_to "$selected_name"; then
  echo "Error: Failed to switch to tmux session '$selected_name'" >&2
  exit 1
fi
