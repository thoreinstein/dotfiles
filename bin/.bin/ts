#!/usr/bin/env bash
#
# ts - Tmux Session Switcher
#
# A fast project switcher for tmux that finds Git repositories and worktrees
# under BASE_DIR and presents them via fzf for quick session switching.
#
# Usage: ts [OPTIONS]
#   -u, --update    Force update the repository cache
#   -h, --help      Show help message
#
# Environment:
#   TS_BASE_DIR     Override default base directory (default: ~/src)
#   TS_CACHE_FILE   Override cache file location
#   TS_CACHE_AGE    Override cache max age in seconds (default: 3600)

set -euo pipefail

# Save original directory to restore later
ORIGINAL_DIR="$PWD"
trap 'cd "$ORIGINAL_DIR" 2>/dev/null || true' EXIT

BASE_DIR="${TS_BASE_DIR:-${HOME}/src}"
CACHE_FILE="${TS_CACHE_FILE:-${HOME}/.cache/ts_repos.cache}"
CACHE_MAX_AGE="${TS_CACHE_AGE:-3600}"  # 1 hour in seconds

# Get the absolute path of the script for parallel execution
if [[ "$OSTYPE" == "darwin"* ]]; then
  # macOS doesn't always have realpath/readlink -f by default
  SCRIPT_PATH="$(cd "$(dirname "$0")" && pwd)/$(basename "$0")"
else
  SCRIPT_PATH="$(readlink -f "$0")"
fi

# Function definitions

# Helper function to truncate strings with ellipsis
truncate_string() {
  local str="$1"
  local max_len="$2"

  if [[ ${#str} -le $max_len ]]; then
    echo "$str"
  else
    echo "${str:0:$((max_len - 3))}..."
  fi
}

# Check if cache is valid
is_cache_valid() {
  if [[ ! -f "$CACHE_FILE" ]]; then
    return 1
  fi

  local cache_time=0
  # Check if we have GNU stat or BSD stat
  if stat --version 2>/dev/null | grep -q "GNU coreutils"; then
    cache_time=$(stat -c "%Y" -- "$CACHE_FILE" 2>/dev/null || echo 0)
  else
    cache_time=$(stat -f "%m" -- "$CACHE_FILE" 2>/dev/null || echo 0)
  fi

  # Ensure cache_time is a number to avoid "unbound variable" errors in arithmetic
  if [[ ! "$cache_time" =~ ^[0-9]+$ ]]; then
    cache_time=0
  fi

  local current_time
  current_time=$(date +%s)
  local age=$((current_time - cache_time))

  [[ $age -lt $CACHE_MAX_AGE ]]
}

# Internal function to process a single repository path
internal_process_repo() {
  local objects_path="$1"
  local repo_path=""

  # Remove trailing slash if present
  objects_path="${objects_path%/}"

  if [[ "$objects_path" == */.git/objects ]]; then
    repo_path="${objects_path%/.git/objects}"
  else
    repo_path="${objects_path%/objects}"
  fi
  
  # Ensure repo_path is not empty and exists
  repo_path="${repo_path:-.}"
  [[ ! -d "$repo_path" ]] && return 0

  # Sanity check: is it a git repo? (Look for HEAD)
  if [[ ! -f "$repo_path/HEAD" && ! -f "$repo_path/.git/HEAD" ]]; then
    return 0
  fi

  # Get remote info once per repository
  local remote_url
  remote_url=$(git -C "$repo_path" config remote.origin.url 2>/dev/null || echo "local/local")
  
  local remote_info
  if [[ "$remote_url" =~ (github|gitlab|bitbucket)\.com[:/]([^/]+)/([^/.]+) ]]; then
    remote_info="${BASH_REMATCH[2]}/${BASH_REMATCH[3]}"
  else
    # Handle cases where remote might be a path or non-standard URL
    local base_remote=$(basename "$remote_url" .git)
    remote_info="other/${base_remote:-local}"
  fi

  local repo_name=$(basename "$repo_path")

  # Process all worktrees for this repo_path
  local wt_path=""
  local is_bare=0
  
  # Use while read to process porcelain worktree list
  while read -r line; do
    if [[ "$line" =~ ^worktree[[:space:]]+(.+)$ ]]; then
      wt_path="${BASH_REMATCH[1]}"
      is_bare=0
    elif [[ "$line" == "bare" ]]; then
      is_bare=1
    elif [[ "$line" =~ ^HEAD[[:space:]] ]]; then
      if [[ $is_bare -eq 0 && -n "$wt_path" && -d "$wt_path" ]]; then
        local wt_name=$(basename "$wt_path")
        
        # Get status and branch in one call
        local status_info
        status_info=$(git -C "$wt_path" status --porcelain=v1 --branch 2>/dev/null || true)
        
        local branch="detached"
        local status="Clean"
        
        if [[ -n "$status_info" ]]; then
          local first_line
          first_line=$(echo "$status_info" | head -n 1)
          if [[ "$first_line" =~ ^##[[:space:]](No[[:space:]]commits[[:space:]]yet[[:space:]]on[[:space:]])?([^.[:space:]]+) ]]; then
            branch="${BASH_REMATCH[2]}"
            branch="${branch#refs/heads/}"
          fi
          
          local changes
          changes=$(echo "$status_info" | tail -n +2)
          if [[ -n "$changes" ]]; then
            if echo "$changes" | grep -q '^[MADRC]'; then
              status="Staged"
            else
              status="Dirty"
            fi
          fi
        fi
        
        # Truncate values for table formatting
        local truncated_remote=$(truncate_string "$remote_info" 25)
        local truncated_repo=$(truncate_string "$repo_name" 18)
        local truncated_branch=$(truncate_string "$branch" 20)
        local truncated_worktree=$(truncate_string "$wt_name" 15)

        # Format: Display Line \t Worktree Name \t Repo Name \t Path
        printf "%-25s | %-18s | %-15s | %-20s | %-8s\t%s\t%s\t%s\n" \
          "$truncated_remote" \
          "$truncated_repo" \
          "$truncated_worktree" \
          "$truncated_branch" \
          "$status" \
          "$wt_name" \
          "$repo_name" \
          "$wt_path"
      fi
      # Reset for next entry
      wt_path=""
      is_bare=0
    fi
  done < <(git -C "$repo_path" worktree list --porcelain 2>/dev/null)
  
  return 0
}

# Function to build repository list
build_repo_list() {
  local verbose="${1:-true}"
  
  if [[ "$verbose" == "true" ]]; then
    echo "Scanning repositories in $BASE_DIR..." >&2
  fi

  local find_cmd
  if command -v fd &> /dev/null; then
    # -H for hidden, -I to ignore .gitignore (we WANT to find .git directories)
    find_cmd="fd -H -I -d 5 -t d '^objects$' \"$BASE_DIR\""
  else
    find_cmd="find \"$BASE_DIR\" -maxdepth 5 -type d -name objects"
  fi

  # Determine parallelism
  local nproc
  if [[ "$OSTYPE" == "darwin"* ]]; then
    nproc=$(sysctl -n hw.ncpu 2>/dev/null || echo 4)
  else
    nproc=$(nproc 2>/dev/null || echo 4)
  fi

  # Use temp file for atomic update
  local temp_cache="${CACHE_FILE}.tmp.$$"
  
  # Ensure cache directory exists
  mkdir -p "$(dirname "$CACHE_FILE")"

  # Run discovery and processing in parallel
  eval "$find_cmd" | xargs -I {} -P "$nproc" "$SCRIPT_PATH" --internal-process-repo "{}" > "$temp_cache"

  mv "$temp_cache" "$CACHE_FILE"

  if [[ "$verbose" == "true" ]]; then
    local count
    count=$(wc -l < "$CACHE_FILE")
    echo "Repository cache updated ($count repositories found)" >&2
  fi
}

switch_to() {
  local session_name="$1"
  if [[ -z "${TMUX:-}" ]]; then
    tmux attach-session -t "=$session_name"
  else
    tmux switch-client -t "=$session_name"
  fi
}

has_session() {
  local session_name="$1"
  tmux has-session -t "=$session_name" 2>/dev/null
}

# Parse command line arguments
UPDATE_CACHE=false

if [[ "${1:-}" == "--internal-process-repo" ]]; then
  internal_process_repo "$2"
  exit 0
fi

if [[ "${1:-}" == "--internal-update-cache" ]]; then
  build_repo_list "false"
  exit 0
fi

if [[ "${1:-}" == "--update" ]] || [[ "${1:-}" == "-u" ]]; then
  UPDATE_CACHE=true
elif [[ "${1:-}" == "--help" ]] || [[ "${1:-}" == "-h" ]]; then
  echo "Usage: ts [OPTIONS]"
  echo ""
  echo "Tmux session switcher for Git repositories"
  echo ""
  echo "Options:"
  echo "  -u, --update    Force update the repository cache"
  echo "  -h, --help      Show this help message"
  echo ""
  echo "The script caches repository information for 1 hour to improve performance."
  echo "It will automatically update the cache in the background if it is stale."
  echo "Use --update to force a synchronous refresh of the cache."
  exit 0
fi

# Check for required dependencies
for cmd in tmux git fzf; do
  if ! command -v "$cmd" &> /dev/null; then
    echo "Error: Required command '$cmd' not found" >&2
    exit 1
  fi
done

# Check if BASE_DIR exists
if [[ ! -d "$BASE_DIR" ]]; then
  echo "Error: Base directory '$BASE_DIR' does not exist" >&2
  exit 1
fi

declare -a options=()

# Logic to load or build cache
if [[ "$UPDATE_CACHE" == "true" ]]; then
  # Explicit update requested
  build_repo_list "true"
elif [[ ! -f "$CACHE_FILE" ]]; then
  # No cache exists, must build
  build_repo_list "true"
else
  # Cache exists
  if ! is_cache_valid; then
    # Cache is stale, trigger background update
    nohup "$SCRIPT_PATH" --internal-update-cache >/dev/null 2>&1 &
  fi
  # Proceed to use existing cache (even if stale)
fi

# Load from cache
if [[ -f "$CACHE_FILE" ]]; then
  while IFS= read -r line; do
    options+=("$line")
  done < "$CACHE_FILE"
fi

# Check if we have any options
if [[ ${#options[@]} -eq 0 ]]; then
  echo "No git repositories found in $BASE_DIR" >&2
  exit 1
fi

# Present options via fzf
selected=$(printf '%s\n' "${options[@]}" | fzf \
  --tmux 100%,90% \
  --with-nth=1 \
  --delimiter=$'\t' \
  --preview='echo "Path: {4}"; echo ""; ls -la {4}' \
  --layout=reverse \
  --prompt='Select Repository > ' \
  --header="$(printf "%-25s | %-18s | %-15s | %-20s | %-8s" "GitHub Org/Repo" "Repository" "Worktree" "Branch" "Status")" \
  --bind='?:toggle-preview' 2>/dev/null) || exit 0

# Check if selection is empty
if [[ -z "$selected" ]]; then
  exit 0
fi

# Extract fields from the selected line
IFS=$'\t' read -r _ worktree_name repo_name selected_path <<< "$selected"

# Validate extracted fields
if [[ -z "$worktree_name" ]] || [[ -z "$repo_name" ]] || [[ -z "$selected_path" ]]; then
  echo "Error: Failed to parse selection" >&2
  exit 1
fi

# Verify the selected path exists
if [[ ! -d "$selected_path" ]]; then
  echo "Error: Selected path '$selected_path' does not exist" >&2
  exit 1
fi

worktree=$(echo "$worktree_name" | xargs)
selected_name="${repo_name} [${worktree}]"

# Check if tmux server is running
tmux_running=false
if tmux list-sessions &>/dev/null; then
  tmux_running=true
fi

if [[ -z "${TMUX:-}" ]] && [[ "$tmux_running" == "false" ]]; then
  if ! tmux new-session -s "$selected_name" -c "$selected_path"; then
    echo "Error: Failed to create new tmux session" >&2
    exit 1
  fi
  exit 0
fi

# Create session if it doesn't exist
if ! has_session "$selected_name"; then
  if ! tmux new-session -ds "$selected_name" -c "$selected_path"; then
    echo "Error: Failed to create detached tmux session" >&2
    exit 1
  fi
fi

# Switch to the session
if ! switch_to "$selected_name"; then
  echo "Error: Failed to switch to tmux session '$selected_name'" >&2
  exit 1
fi
